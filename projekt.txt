
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\pom.xml
--------------------------------------------------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version>
        <relativePath/>
    </parent>

    <groupId>com.fitconnect</groupId>
    <artifactId>backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>fitconnect-backend</name>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Web & REST -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Security -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- PostgreSQL DB -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.7.2</version>
        </dependency>

        <!-- JPA / Hibernate -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- JWT optional -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\FitconnectBackendApplication.java
--------------------------------------------------------------------------------
package com.fitconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FitconnectBackendApplication {

    public static void main(String[] args) {
        SpringApplication.run(FitconnectBackendApplication.class, args);
    }
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\ActivityController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;

import com.fitconnect.dto.ActivityRequest;
import com.fitconnect.entity.Activity;
import com.fitconnect.entity.Visibility;
import com.fitconnect.repository.ActivityRepository;
import com.fitconnect.service.FeedSseService;
import com.fitconnect.service.FriendshipService;

import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/activities")
public class ActivityController {

    private final ActivityRepository activityRepository;
    private final FeedSseService feedSseService;

    private final FriendshipService friendshipService;

    public ActivityController(ActivityRepository activityRepository,
                            FeedSseService feedSseService,
                            FriendshipService friendshipService) {
        this.activityRepository = activityRepository;
        this.feedSseService = feedSseService;
        this.friendshipService = friendshipService;
    }

    @GetMapping("/feed-stream")
    public SseEmitter subscribeToFeed() {
        return feedSseService.subscribe();
    }

    @PostMapping
    public ResponseEntity<Activity> postActivity(@RequestBody ActivityRequest request, Authentication auth) {
        Activity activity = new Activity(auth.getName(), request.text(), request.location());
        activity.setVisibility(Visibility.valueOf(request.visibility().toUpperCase())); // z.â€¯B. "FRIENDS_ONLY"
        activityRepository.save(activity);
        feedSseService.broadcast(activity);
        return ResponseEntity.ok(activity);
    }

   @GetMapping
public List<Activity> getFeed(Authentication auth) {
    String viewer = auth.getName();
    return activityRepository.findAllByOrderByTimestampDesc().stream()
        .filter(a -> {
            if (a.getUser().equals(viewer)) return true;
            return switch (a.getVisibility()) {
                case PUBLIC -> true;
                case PRIVATE -> false;
                case FRIENDS_ONLY -> friendshipService.areFriends(viewer, a.getUser());
            };
        })
        .toList();
}

    @PutMapping("/{id}")
    public ResponseEntity<?> update(@PathVariable Long id, @RequestBody ActivityRequest request, Authentication auth) {
        Optional<Activity> optional = activityRepository.findById(id);
        if (optional.isEmpty()) return ResponseEntity.notFound().build();

        Activity activity = optional.get();
        if (!activity.getUser().equals(auth.getName())) return ResponseEntity.status(403).build();

        activity.setText(request.text());
        activity.setLocation(request.location()); // ðŸ†•
        activityRepository.save(activity);
        feedSseService.broadcastUpdate(activity);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> delete(@PathVariable Long id, Authentication auth) {
        Optional<Activity> optional = activityRepository.findById(id);
        if (optional.isEmpty()) return ResponseEntity.notFound().build();

        Activity activity = optional.get();
        if (!activity.getUser().equals(auth.getName())) return ResponseEntity.status(403).build();

        activityRepository.deleteById(id);
        feedSseService.broadcastDelete(id); // LÃ¶sch-ID senden
        return ResponseEntity.ok().build();
    }

    @GetMapping("/me/activities")
    public List<Activity> getOwnActivities(Authentication auth) {
        return activityRepository.findByUserOrderByTimestampDesc(auth.getName());
    }


}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\AuthController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;

import com.fitconnect.dto.AuthRequest;
import com.fitconnect.dto.AuthResponse;
import com.fitconnect.service.AuthService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@RequestBody AuthRequest request) {
        return ResponseEntity.ok(authService.register(request));
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@RequestBody AuthRequest request) {
        return ResponseEntity.ok(authService.login(request));
    } 
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\FriendshipController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;

import com.fitconnect.entity.Friendship;
import com.fitconnect.entity.User;
import com.fitconnect.service.FriendshipService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/friends")
public class FriendshipController {

    private final FriendshipService friendshipService;

    public FriendshipController(FriendshipService friendshipService) {
        this.friendshipService = friendshipService;
    }

    @PostMapping("/request/{targetUsername}")
    public ResponseEntity<Void> sendRequest(Authentication auth,
                                            @PathVariable String targetUsername) {
        friendshipService.sendRequest(auth.getName(), targetUsername);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/respond/{requestId}")
    public ResponseEntity<Void> respondToRequest(@PathVariable Long requestId,
                                                 @RequestParam boolean accept) {
        friendshipService.respondToRequest(requestId, accept);
        return ResponseEntity.ok().build();
    }

    @GetMapping
    public ResponseEntity<List<User>> listFriends(Authentication auth) {
        return ResponseEntity.ok(friendshipService.listFriends(auth.getName()));
    }

    @GetMapping("/requests")
    public ResponseEntity<List<Friendship>> listPending(Authentication auth) {
        return ResponseEntity.ok(friendshipService.listPendingRequests(auth.getName()));
    }

    @GetMapping("/{username}/status")
    public ResponseEntity<String> getFriendshipStatus(Authentication auth, @PathVariable String username) {
        String currentUser = auth.getName();
        String status = friendshipService.getFriendshipStatus(currentUser, username);
        return ResponseEntity.ok(status);
    }

    @DeleteMapping("/remove/{username}")
    public ResponseEntity<Void> removeFriend(Authentication auth, @PathVariable String username) {
        friendshipService.removeFriendship(auth.getName(), username);
        return ResponseEntity.ok().build();
    }


}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\GroupController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;


import com.fitconnect.entity.Group;
import com.fitconnect.entity.GroupParticipant;
import com.fitconnect.entity.User;
import com.fitconnect.repository.GroupParticipantRepository;
import com.fitconnect.repository.GroupRepository;
import com.fitconnect.repository.UserRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/groups")
public class GroupController {

    private final GroupRepository groupRepo;
    private final UserRepository userRepo;
    private final GroupParticipantRepository participantRepo;

    public GroupController(GroupRepository groupRepo, UserRepository userRepo, GroupParticipantRepository participantRepo) {
        this.groupRepo = groupRepo;
        this.userRepo = userRepo;
        this.participantRepo = participantRepo;
    }

    @PostMapping
    public ResponseEntity<Group> createGroup(@RequestParam String name, Authentication auth) {
        Group group = new Group();
        group.setName(name);
        group.setCreatedBy(auth.getName());
        groupRepo.save(group);

        User creator = userRepo.findById(auth.getName()).orElseThrow();
        participantRepo.save(new GroupParticipant(group, creator, GroupParticipant.Role.ADMIN));

        return ResponseEntity.ok(group);
    }

    @PostMapping("/{id}/invite")
    public ResponseEntity<?> inviteToGroup(
            @PathVariable Long id,
            @RequestParam String friendUsername,
            Authentication auth) {

        String currentUser = auth.getName();

        // âœ… Nur Admins dÃ¼rfen einladen
        boolean isAdmin = participantRepo
            .findByGroupIdAndUserUsername(id, currentUser)
            .map(p -> p.getRole() == GroupParticipant.Role.ADMIN)
            .orElse(false);

        if (!isAdmin) {
            return ResponseEntity.status(403).body("Nur Admins dÃ¼rfen Mitglieder einladen.");
        }

        // â›” Bereits Mitglied?
        if (participantRepo.existsByGroupIdAndUserUsername(id, friendUsername)) {
            return ResponseEntity.ok("Schon Mitglied.");
        }

        Group group = groupRepo.findById(id).orElseThrow();
        User friend = userRepo.findById(friendUsername).orElseThrow();

        participantRepo.save(new GroupParticipant(group, friend, GroupParticipant.Role.MEMBER));
        return ResponseEntity.ok().build();
    }
    @GetMapping
    public ResponseEntity<List<Group>> myGroups(Authentication auth) {
        List<GroupParticipant> participation = participantRepo.findByUserUsername(auth.getName());
        List<Group> result = participation.stream()
            .map(GroupParticipant::getGroup)
            .toList();
        return ResponseEntity.ok(result);
    }

    @GetMapping("/{id}/members")
    public ResponseEntity<List<User>> getGroupMembers(@PathVariable Long id, Authentication auth) {
        String currentUser = auth.getName();
        boolean isMember = participantRepo.existsByGroupIdAndUserUsername(id, currentUser);
        if (!isMember) return ResponseEntity.status(403).build();

        return ResponseEntity.ok(participantRepo.findUsersByGroupId(id));
    }


    @GetMapping("/{id}")
    public ResponseEntity<Group> getGroup(@PathVariable Long id, Authentication auth) {
        String currentUser = auth.getName();
        boolean isMember = participantRepo.existsByGroupIdAndUserUsername(id, currentUser);
        if (!isMember) return ResponseEntity.status(403).build();

        return ResponseEntity.of(groupRepo.findById(id));
    }



}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\GroupMessageController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;

import com.fitconnect.entity.Group;
import com.fitconnect.entity.GroupMessage;
import com.fitconnect.entity.User;
import com.fitconnect.repository.GroupMessageRepository;
import com.fitconnect.repository.GroupParticipantRepository;
import com.fitconnect.repository.GroupRepository;
import com.fitconnect.repository.UserRepository;
import com.fitconnect.service.FeedSseService;

import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/group-messages")
public class GroupMessageController {

    private final GroupRepository groupRepo;
    private final GroupParticipantRepository participantRepo;
    private final GroupMessageRepository messageRepo;
    private final UserRepository userRepo;
    private final FeedSseService feedSseService;

    public GroupMessageController(GroupRepository groupRepo, GroupParticipantRepository participantRepo,
                                  GroupMessageRepository messageRepo, UserRepository userRepo, FeedSseService feedSseService) {
        this.groupRepo = groupRepo;
        this.participantRepo = participantRepo;
        this.messageRepo = messageRepo;
        this.userRepo = userRepo;
        this.feedSseService=feedSseService;
    }

    @PostMapping("/{groupId}")
    public ResponseEntity<?> sendMessage(@PathVariable Long groupId,
                                         @RequestParam String text,
                                         Authentication auth) {
        String sender = auth.getName();
        boolean isMember = participantRepo.existsByGroupIdAndUserUsername(groupId, sender);
        if (!isMember) return ResponseEntity.status(403).build();

        Group group = groupRepo.findById(groupId).orElseThrow();
        User user = userRepo.findById(sender).orElseThrow();

        messageRepo.save(new GroupMessage(group, user, text));
        feedSseService.broadcastGroupMessage(groupId, sender);

        return ResponseEntity.ok().build();
    }

    @GetMapping("/{groupId}")
    public ResponseEntity<List<GroupMessage>> getMessages(@PathVariable Long groupId, Authentication auth) {
        String user = auth.getName();
        boolean isMember = participantRepo.existsByGroupIdAndUserUsername(groupId, user);
        if (!isMember) return ResponseEntity.status(403).build();

        Group group = groupRepo.findById(groupId).orElseThrow();
        return ResponseEntity.ok(messageRepo.findByGroupOrderByTimestampAsc(group));
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\MessageController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;

import com.fitconnect.dto.ChatMessageRequest;
import com.fitconnect.dto.ChatPreviewDTO;
import com.fitconnect.entity.Message;
import com.fitconnect.entity.User;
import com.fitconnect.repository.MessageRepository;
import com.fitconnect.repository.UserRepository;
import com.fitconnect.service.FeedSseService;
import com.fitconnect.service.FriendshipService;

import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/messages")
public class MessageController {

    private final MessageRepository messageRepo;
    private final UserRepository userRepo;
    private final FriendshipService friendshipService;
    private final FeedSseService feedSseService;
   
    public MessageController(MessageRepository messageRepo, UserRepository userRepo, FriendshipService friendshipService,FeedSseService feedSseService) {
        this.messageRepo = messageRepo;
        this.userRepo = userRepo;
        this.friendshipService = friendshipService;
        this.feedSseService = feedSseService;
    }

    @PostMapping
    public ResponseEntity<?> sendMessage(@RequestBody ChatMessageRequest req, Authentication auth) {
        String senderUsername = auth.getName();
        if (!friendshipService.areFriends(senderUsername, req.recipient)) {
            return ResponseEntity.status(403).body("Nur Freunde dÃ¼rfen sich schreiben.");
        }

        User sender = userRepo.findById(senderUsername).orElseThrow();
        User recipient = userRepo.findById(req.recipient).orElseThrow();
        Message message = new Message(sender, recipient, req.text);
        messageRepo.save(message);

        feedSseService.broadcastMessage(req.recipient, senderUsername);
        
        // SSE push spÃ¤ter in Sprint 13.4
        return ResponseEntity.ok().build();
    }

    @GetMapping("/{with}")
    public ResponseEntity<List<Message>> getConversation(@PathVariable String with, Authentication auth) {
        String currentUser = auth.getName();
        if (!friendshipService.areFriends(currentUser, with)) {
            return ResponseEntity.status(403).build();
        }

        User u1 = userRepo.findById(currentUser).orElseThrow();
        User u2 = userRepo.findById(with).orElseThrow();
        return ResponseEntity.ok(messageRepo.getConversation(u1, u2));
    }


    @GetMapping("/overview")
    public ResponseEntity<List<ChatPreviewDTO>> getChatOverview(Authentication auth) {
        String currentUser = auth.getName();
        List<Object[]> raw = messageRepo.findChatOverviews(currentUser);

        List<ChatPreviewDTO> result = raw.stream()
            .map(row -> new ChatPreviewDTO(
                (String) row[0],
                (String) row[1],
                ((java.sql.Timestamp) row[2]).toLocalDateTime()
            ))
            .toList();

        return ResponseEntity.ok(result);
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\controller\UserController.java
--------------------------------------------------------------------------------
package com.fitconnect.controller;



import com.fitconnect.entity.User;
import com.fitconnect.repository.UserRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping("/search")
    public ResponseEntity<List<User>> searchUsers(@RequestParam String query) {
        var result = userRepository.findByUsernameContainingIgnoreCase(query);
        return ResponseEntity.ok(result);
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\dto\ActivityRequest.java
--------------------------------------------------------------------------------
package com.fitconnect.dto;

public record ActivityRequest(String text, String location, String visibility) {}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\dto\AuthRequest.java
--------------------------------------------------------------------------------
package com.fitconnect.dto;

public class AuthRequest {
    public String username;
    public String password;
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\dto\AuthResponse.java
--------------------------------------------------------------------------------
package com.fitconnect.dto;

public class AuthResponse {
    public String token;

    public AuthResponse(String token) {
        this.token = token;
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\dto\ChatMessageRequest.java
--------------------------------------------------------------------------------
package com.fitconnect.dto;

public class ChatMessageRequest {
    public String recipient;
    public String text;
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\dto\ChatPreviewDTO.java
--------------------------------------------------------------------------------
package com.fitconnect.dto;

import java.time.LocalDateTime;

public class ChatPreviewDTO {
    public String username;
    public String lastMessage;
    public LocalDateTime timestamp;

    public ChatPreviewDTO(String username, String lastMessage, LocalDateTime timestamp) {
        this.username = username;
        this.lastMessage = lastMessage;
        this.timestamp = timestamp;
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\Activity.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;

import jakarta.persistence.*;

@Entity
public class Activity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username")
    private String user;

    private String text;
    private long timestamp;

    private String location; // ðŸ†• z.â€¯B. "Darmstadt Marktplatz"


    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Visibility visibility = Visibility.PUBLIC;

    // Getter & Setter
    public Visibility getVisibility() { return visibility; }
    public void setVisibility(Visibility visibility) { this.visibility = visibility; }

    public Activity() {}

    public Activity(String user, String text, String location) {
        this.user = user;
        this.text = text;
        this.location = location;
        this.timestamp = System.currentTimeMillis();
    }

    // Getter & Setter
    public Long getId() { return id; }
    public String getUser() { return user; }
    public String getText() { return text; }
    public long getTimestamp() { return timestamp; }
    public String getLocation() { return location; }

    public void setText(String text) {
        this.text = text;
    }

    public void setLocation(String location) {
        this.location = location;
    }
}

.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\Friendship.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;



import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class Friendship {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    private User requester;

    @ManyToOne
    private User addressee;

    @Enumerated(EnumType.STRING)
    private FriendshipStatus status;

    private LocalDateTime createdAt;

    public Friendship() {}

    public Friendship(User requester, User addressee, FriendshipStatus status) {
        this.requester = requester;
        this.addressee = addressee;
        this.status = status;
        this.createdAt = LocalDateTime.now();
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public User getRequester() {
        return requester;
    }

    public void setRequester(User requester) {
        this.requester = requester;
    }

    public User getAddressee() {
        return addressee;
    }

    public void setAddressee(User addressee) {
        this.addressee = addressee;
    }

    public FriendshipStatus getStatus() {
        return status;
    }

    public void setStatus(FriendshipStatus status) {
        this.status = status;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

   
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\FriendshipStatus.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;


public enum FriendshipStatus {
    PENDING,
    ACCEPTED,
    REJECTED
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\Group.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;

import java.time.LocalDateTime;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "\"group\"") // escaped table name
public class Group {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String createdBy;

    private LocalDateTime createdAt = LocalDateTime.now();

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    // Getter/Setter ...
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\GroupMessage.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class GroupMessage {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false)
    private Group group;

    @ManyToOne(optional = false)
    private User sender;

    @Column(nullable = false)
    private String text;

    private LocalDateTime timestamp = LocalDateTime.now();

    public GroupMessage() {}

    public GroupMessage(Group group, User sender, String text) {
        this.group = group;
        this.sender = sender;
        this.text = text;
    }

    // Getter
    public Long getId() { return id; }
    public Group getGroup() { return group; }
    public User getSender() { return sender; }
    public String getText() { return text; }
    public LocalDateTime getTimestamp() { return timestamp; }
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\GroupParticipant.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;

import jakarta.persistence.*;

@Entity
public class GroupParticipant {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false)
    private Group group;

    @ManyToOne(optional = false)
    private User user;

    @Enumerated(EnumType.STRING)
    private Role role = Role.MEMBER;

    public enum Role {
        ADMIN,
        MEMBER
    }

    public GroupParticipant() {}

    public GroupParticipant(Group group, User user, Role role) {
        this.group = group;
        this.user = user;
        this.role = role;
    }

    // Getter und Setter
    public Long getId() {
        return id;
    }

    public Group getGroup() {
        return group;
    }

    public void setGroup(Group group) {
        this.group = group;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\Message.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false)
    private User sender;

    @ManyToOne(optional = false)
    private User recipient;

    @Column(nullable = false)
    private String text;

    private LocalDateTime timestamp = LocalDateTime.now();

    public Message() {}

    public Message(User sender, User recipient, String text) {
        this.sender = sender;
        this.recipient = recipient;
        this.text = text;
        this.timestamp = LocalDateTime.now();
    }

    // Getter
    public Long getId() { return id; }
    public User getSender() { return sender; }
    public User getRecipient() { return recipient; }
    public String getText() { return text; }
    public LocalDateTime getTimestamp() { return timestamp; }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\User.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "users") // optional
public class User {

    @Id
    private String username;

    private String password;

    public User() {}

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() { return username; }
    public String getPassword() { return password; }

    public void setUsername(String username) { this.username = username; }
    public void setPassword(String password) { this.password = password; }
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\entity\Visibility.java
--------------------------------------------------------------------------------
package com.fitconnect.entity;



public enum Visibility {
    PUBLIC,
    FRIENDS_ONLY,
    PRIVATE
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\ActivityRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;

import com.fitconnect.entity.Activity;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface ActivityRepository extends JpaRepository<Activity, Long> {
    List<Activity> findAllByOrderByTimestampDesc();
    List<Activity> findByUserOrderByTimestampDesc(String user);

}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\FriendshipRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;


import com.fitconnect.entity.Friendship;
import com.fitconnect.entity.FriendshipStatus;
import com.fitconnect.entity.User;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;

import java.util.List;


public interface FriendshipRepository extends JpaRepository<Friendship, Long> {

    List<Friendship> findByAddresseeAndStatus(User addressee, FriendshipStatus status);

    @Query("""
    SELECT f FROM Friendship f
    WHERE ((f.requester = :user1 AND f.addressee = :user2)
       OR (f.requester = :user2 AND f.addressee = :user1))
       AND f.status = 'ACCEPTED'
    """)
    List<Friendship> findFriendshipsBetween(@Param("user1") User u1, @Param("user2") User u2);
    

    @Query("""
        SELECT f.addressee FROM Friendship f
        WHERE f.requester = :user AND f.status = 'ACCEPTED'
        UNION
        SELECT f.requester FROM Friendship f
        WHERE f.addressee = :user AND f.status = 'ACCEPTED'
    """)
    List<User> findAllFriendsOf(@Param("user") User user);
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\GroupMessageRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;

import com.fitconnect.entity.Group;
import com.fitconnect.entity.GroupMessage;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface GroupMessageRepository extends JpaRepository<GroupMessage, Long> {
    List<GroupMessage> findByGroupOrderByTimestampAsc(Group group);
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\GroupParticipantRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import com.fitconnect.entity.GroupParticipant;
import com.fitconnect.entity.User;

public interface GroupParticipantRepository extends JpaRepository<GroupParticipant, Long> {
   
    List<GroupParticipant> findByUserUsername(String username);
   
    boolean existsByGroupIdAndUserUsername(Long groupId, String username);


    @Query("SELECT gp.user FROM GroupParticipant gp WHERE gp.group.id = :groupId")
    List<User> findUsersByGroupId(@Param("groupId") Long groupId);

    Optional<GroupParticipant> findByGroupIdAndUserUsername(Long groupId, String username);
    
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\GroupRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.fitconnect.entity.Group;

public interface GroupRepository extends JpaRepository<Group, Long> {
    List<Group> findByCreatedBy(String username);
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\MessageRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;

import com.fitconnect.entity.Message;
import com.fitconnect.entity.User;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface MessageRepository extends JpaRepository<Message, Long> {

    @Query("""
        SELECT m FROM Message m
        WHERE (m.sender = :user1 AND m.recipient = :user2)
           OR (m.sender = :user2 AND m.recipient = :user1)
        ORDER BY m.timestamp ASC
    """)
    List<Message> getConversation(@Param("user1") User a, @Param("user2") User b);


    @Query(value = """
    SELECT DISTINCT ON (LEAST(m.sender_username, m.recipient_username), GREATEST(m.sender_username, m.recipient_username))
           CASE WHEN m.sender_username = :current THEN m.recipient_username ELSE m.sender_username END as username,
           m.text as last_message,
           m.timestamp
    FROM message m
    WHERE m.sender_username = :current OR m.recipient_username = :current
    ORDER BY LEAST(m.sender_username, m.recipient_username),
             GREATEST(m.sender_username, m.recipient_username),
             m.timestamp DESC
""", nativeQuery = true)
List<Object[]> findChatOverviews(@Param("current") String currentUser);
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\repository\UserRepository.java
--------------------------------------------------------------------------------
package com.fitconnect.repository;

import com.fitconnect.entity.User;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, String> {

    List<User> findByUsernameContainingIgnoreCase(String query);

}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\security\CorsConfig.java
--------------------------------------------------------------------------------
package com.fitconnect.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.*;

@Configuration
public class CorsConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("http://127.0.0.1:5500")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        };
    }
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\security\JwtAuthFilter.java
--------------------------------------------------------------------------------
package com.fitconnect.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil = new JwtUtil();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        System.out.println("ðŸ” Auth-Header: " + request.getHeader("Authorization"));

        // âœ… komplett Ã¼berspringen bei SSE-Endpunkt
        if (request.getRequestURI().equals("/activities/feed-stream")) {
            // SSE Endpunkt => SecurityContext lÃ¶schen / oder skip
            SecurityContextHolder.clearContext();
            filterChain.doFilter(request, response);
            return;
        }

        final String authHeader = request.getHeader("Authorization");

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            String username = jwtUtil.validateTokenAndGetUsername(token);

            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                var auth = new UsernamePasswordAuthenticationToken(
                        username, null, Collections.emptyList());
                auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        }

        filterChain.doFilter(request, response);
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\security\JwtUtil.java
--------------------------------------------------------------------------------
package com.fitconnect.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

public class JwtUtil {

    private static final SecretKey SECRET_KEY = Keys.hmacShaKeyFor(
        "my-super-secret-key-which-is-32-bytes!!".getBytes(StandardCharsets.UTF_8)
    );

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 86400000))
                .signWith(SECRET_KEY)
                .compact();
    }

    public String validateTokenAndGetUsername(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(SECRET_KEY)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
            return claims.getSubject();
        } catch (JwtException e) {
            return null;
        }
    }
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\security\SecurityConfig.java
--------------------------------------------------------------------------------
package com.fitconnect.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;

@Configuration
public class SecurityConfig {

    @Autowired
    private JwtAuthFilter jwtAuthFilter;

    @Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable())
   
        .authorizeHttpRequests(auth -> auth
        .requestMatchers("/auth/**", "/activities/feed-stream").permitAll()
        .requestMatchers("/activities/**").authenticated()
        .requestMatchers("/friends/**").authenticated()
        .requestMatchers("/users/search").authenticated()
        .requestMatchers("/messages/**").authenticated()
        .requestMatchers("/groups/**").authenticated()
        .requestMatchers("/group-messages/**").authenticated()
        
        .anyRequest().denyAll()
)
        .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
        .httpBasic(Customizer.withDefaults());

    return http.build();
}
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\service\AuthService.java
--------------------------------------------------------------------------------
package com.fitconnect.service;

import com.fitconnect.dto.AuthRequest;
import com.fitconnect.dto.AuthResponse;
import com.fitconnect.entity.User;
import com.fitconnect.repository.UserRepository;
import com.fitconnect.security.JwtUtil;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class AuthService {

    private final UserRepository userRepository;
    private final JwtUtil jwtUtil = new JwtUtil();
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public AuthResponse register(AuthRequest request) {
        if (userRepository.existsById(request.username)) {
            throw new RuntimeException("Benutzername ist bereits vergeben");
        }

        User user = new User(request.username, encoder.encode(request.password));
        userRepository.save(user);
        String token = jwtUtil.generateToken(user.getUsername());
        return new AuthResponse(token);
    }

    public AuthResponse login(AuthRequest request) {
        User user = userRepository.findById(request.username)
                .orElseThrow(() -> new RuntimeException("Benutzer nicht gefunden"));

        if (!encoder.matches(request.password, user.getPassword())) {
            throw new RuntimeException("Falsches Passwort");
        }

        String token = jwtUtil.generateToken(user.getUsername());
        return new AuthResponse(token);
    }
}

.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\service\FeedSseService.java
--------------------------------------------------------------------------------
package com.fitconnect.service;

import com.fitconnect.entity.Activity;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
public class FeedSseService {

    private final List<SseEmitter> clients = new CopyOnWriteArrayList<>();

    public SseEmitter subscribe() {
        SseEmitter emitter = new SseEmitter(30 * 60 * 1000L); // 30 Minuten
        clients.add(emitter);

        emitter.onCompletion(() -> clients.remove(emitter));
        emitter.onTimeout(() -> clients.remove(emitter));
        emitter.onError(e -> clients.remove(emitter));

        return emitter;
    }

    public void broadcast(Activity activity) {
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("activity")
                    .data(activity));
            } catch (IOException e) {
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }

    public void broadcastUpdate(Activity activity) {
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("activity-update")
                    .data(activity));
            } catch (IOException e) {
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }
    
    public void broadcastDelete(Long activityId) {
        System.out.println("ðŸ“£ DELETE wird gesendet an " + clients.size() + " Clients fÃ¼r ID " + activityId);
    
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("activity-delete")
                    .data(activityId));
            } catch (IOException e) {
                System.out.println("âŒ Fehler beim Senden an einen Client: " + e.getMessage());
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }


    public void broadcastFriendRequest(String targetUsername) {
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("friend-request")
                    .data(targetUsername));
            } catch (IOException e) {
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }



    public void broadcastMessage(String toUsername, String fromUsername) {
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("new-message")
                    .data(toUsername + "|" + fromUsername));
            } catch (IOException e) {
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }

    public void broadcastUnfriend(String targetUsername, String byUsername) {
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("friend-removed")
                    .data(targetUsername + "|" + byUsername));
            } catch (IOException e) {
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }

    public void broadcastGroupMessage(Long groupId, String fromUsername) {
        for (SseEmitter emitter : clients) {
            try {
                emitter.send(SseEmitter.event()
                    .name("group-message-" + groupId)
                    .data(fromUsername));
            } catch (IOException e) {
                emitter.complete();
                clients.remove(emitter);
            }
        }
    }
    


    
}
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\java\com\fitconnect\service\FriendshipService.java
--------------------------------------------------------------------------------
package com.fitconnect.service;

import com.fitconnect.entity.*;
import com.fitconnect.repository.FriendshipRepository;
import com.fitconnect.repository.UserRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class FriendshipService {

    private final FriendshipRepository friendshipRepo;
    private final UserRepository userRepo;

    private final FeedSseService feedSseService;

    public FriendshipService(FriendshipRepository friendshipRepo, UserRepository userRepo, FeedSseService feedSseService) {
        this.friendshipRepo = friendshipRepo;
        this.userRepo = userRepo;
        this.feedSseService = feedSseService;
    }

    public void sendRequest(String requesterUsername, String addresseeUsername) {
        if (requesterUsername.equals(addresseeUsername)) {
            throw new IllegalArgumentException("Du kannst dich nicht selbst hinzufÃ¼gen.");
        }
    
        // Alphabetische Sortierung: requester = min(a, b), addressee = max(a, b)
        String user1 = requesterUsername.compareTo(addresseeUsername) < 0 ? requesterUsername : addresseeUsername;
        String user2 = requesterUsername.compareTo(addresseeUsername) < 0 ? addresseeUsername : requesterUsername;
    
        User requester = userRepo.findById(user1).orElseThrow();
        User addressee = userRepo.findById(user2).orElseThrow();
    
        if (!friendshipRepo.findFriendshipsBetween(requester, addressee).isEmpty()) {
            throw new IllegalStateException("Freundschaft existiert bereits.");
        }
    
        friendshipRepo.save(new Friendship(requester, addressee, FriendshipStatus.PENDING));
        feedSseService.broadcastFriendRequest(addresseeUsername); // original Ziel-Benutzer
    }

    public void respondToRequest(Long requestId, boolean accept) {
        Friendship f = friendshipRepo.findById(requestId).orElseThrow();
        f.setStatus(accept ? FriendshipStatus.ACCEPTED : FriendshipStatus.REJECTED);
        friendshipRepo.save(f);
    }

    public List<User> listFriends(String username) {
        User user = userRepo.findById(username).orElseThrow();
        return friendshipRepo.findAllFriendsOf(user);
    }

    public List<Friendship> listPendingRequests(String username) {
        User user = userRepo.findById(username).orElseThrow();
        return friendshipRepo.findByAddresseeAndStatus(user, FriendshipStatus.PENDING);
    }

    public boolean areFriends(String userA, String userB) {
        User u1 = userRepo.findById(userA).orElseThrow();
        User u2 = userRepo.findById(userB).orElseThrow();
        return !friendshipRepo.findFriendshipsBetween(u1, u2).isEmpty();
    }


    public String getFriendshipStatus(String currentUser, String otherUser) {
        if (currentUser.equals(otherUser)) {
            return "SELF";
        }
    
        User requester = userRepo.findById(currentUser).orElse(null);
        User addressee = userRepo.findById(otherUser).orElse(null);
        if (requester == null || addressee == null) return "UNKNOWN";
    
        List<Friendship> friendships = friendshipRepo.findFriendshipsBetween(requester, addressee);
        if (friendships.isEmpty()) return "NONE";
    
        // Nimm einfach den ersten Status (ggf. erweitern mit PrioritÃ¤tslogik)
        return friendships.get(0).getStatus().name();
    }

    public void removeFriendship(String userA, String userB) {
        User u1 = userRepo.findById(userA).orElseThrow();
        User u2 = userRepo.findById(userB).orElseThrow();
    
        friendshipRepo.findFriendshipsBetween(u1, u2)
            .forEach(friendshipRepo::delete);
    
        feedSseService.broadcastUnfriend(userB, userA); // B erfÃ¤hrt, dass A ihn entfernt hat
    }
    
}

.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\src\main\resources\application.properties
--------------------------------------------------------------------------------
spring.datasource.url=jdbc:postgresql://localhost:5432/fitconnect
spring.datasource.username=postgres
spring.datasource.password=postgres

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

spring.sql.init.mode=always
server.port=8080
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\target\classes\application.properties
--------------------------------------------------------------------------------
spring.datasource.url=jdbc:postgresql://localhost:5432/fitconnect
spring.datasource.username=postgres
spring.datasource.password=postgres

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

spring.sql.init.mode=always
server.port=8080
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\backend\target\maven-archiver\pom.properties
--------------------------------------------------------------------------------
artifactId=backend
groupId=com.fitconnect
version=0.0.1-SNAPSHOT
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\chat-list.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Chat-Ãœbersicht</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span class="greeting">ðŸ’¬ Deine Chats, <strong id="user-name">...</strong></span>
    </div>
    <div class="header-buttons">
      <button onclick="window.location.href='feed.html'">ZurÃ¼ck zum Feed</button>
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>

  <main class="content-container">
    <section class="box">
      <h2>Konversationen</h2>
      <ul id="chat-list" class="chat-list"></ul>
      <p id="error-msg" style="color: red;"></p>
    </section>
  </main>

  <script src="js/chat-list.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\chat.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>fitconnect â€“ Chat</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>

  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span class="greeting">ðŸ’¬ Chat mit <strong id="chat-partner">...</strong></span>
    </div>
    <<div class="header-buttons">
      <button onclick="window.location.href='profile.html'">Mein Profil</button>
      <button onclick="window.location.href='chat-list.html'">ðŸ’¬ Chats</button>
      <button id="friends-btn">ðŸ‘¥ Freunde</button>
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>

  <main class="content-container">
    <section class="box" id="chat-box">
      <ul id="chat-log" class="chat-log"></ul>

      <form id="chat-form" class="inline-form" style="margin-top: 1rem;">
        <input type="text" id="chat-input" placeholder="Nachricht schreiben..." required>
        <button type="submit">Senden</button>
      </form>
    </section>
  </main>

  <script src="js/chat.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\feed.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Feed</title>

  <!-- Mapbox CSS -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span id="user-greeting" class="greeting">ðŸ‘‹ Willkommen, <strong id="user-name">demo</strong></span>
    </div>
    <<div class="header-buttons">
      <button onclick="window.location.href='profile.html'">Mein Profil</button>
      <button onclick="window.location.href='chat-list.html'">ðŸ’¬ Chats</button>
      <button onclick="window.location.href='group-list.html'">ðŸ‘¥ Gruppen</button>
      <button id="friends-btn">ðŸ‘¥ Freunde</button>
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>
  
<!-- ðŸ“¦ Inhalt -->
<main class="content-container">

  <!-- ðŸ“œ Feed -->
  <section class="feed-list-container">
    <ul id="feed-list" class="feed-list"></ul>
  </section>

  

 


  <!-- ðŸ—ºï¸ Karte -->
  <section class="box collapsible">
    <button type="button" class="toggle" onclick="toggleBox(this)">ðŸ—ºï¸ Karte anzeigen</button>
    <div class="content">
      <div id="map" style="height: 300px;"></div>
    </div>
  </section>

  <!-- ðŸ“ AktivitÃ¤ten-Formular -->
  <section class="box">
    <form id="activity-form">
      <input type="text" id="activity-input" placeholder="Was hast du gemacht?" required />
      <input type="text" id="activity-location" placeholder="Ort per Kartenklick auswÃ¤hlen" />
      <small>Klicke auf die Karte, um den Ort deiner AktivitÃ¤t festzulegen</small>
      <select id="activity-visibility">
        <option value="PUBLIC">Ã–ffentlich</option>
        <option value="FRIENDS_ONLY">Nur Freunde</option>
        <option value="PRIVATE">Privat</option>
      </select>
      <button type="submit">Posten</button>
    </form>
    <p id="error-msg" style="color:red;"></p>
  </section>

  
 <!-- ðŸ” Suche -->
 <section class="box collapsible">
  <button type="button" class="toggle" onclick="toggleBox(this)">ðŸ” Benutzer suchen</button>
  <div class="content" style="display: none;">
    <form id="user-search-form" class="inline-form">
      <input type="text" id="search-query" placeholder="Benutzer suchen..." required />
      <button type="submit">ðŸ”</button>
    </form>
    <ul id="search-results" class="result-list"></ul>
  </div>
</section>
  

</main>

  <!-- Mapbox JS -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="js/feed.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\freunde.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Freunde</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span class="greeting">ðŸ‘¤ Eingeloggt als: <strong id="user-name"></strong></span>
    </div>
    <div class="header-buttons">
      <button onclick="window.location.href='feed.html'">ZurÃ¼ck zum Feed</button>
   
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>

  <section>
    <h2>Freundesliste</h2>
    <ul id="friends-list"></ul>

    <h2>Freundschaftsanfragen</h2>
    <ul id="requests-list"></ul>
  </section>

  <script src="js/friends.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\group-chat.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Gruppenchat</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>

  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span class="greeting">ðŸ’¬ Gruppenchat <strong id="group-title">...</strong></span>
    </div>
    <div class="header-buttons">
      <button onclick="window.location.href='group-list.html'">ZurÃ¼ck zu Gruppen</button>
      <button onclick="window.location.href='chat-list.html'">ðŸ’¬ Chats</button>
      <button onclick="window.location.href='feed.html'">Feed</button>
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>

  <main class="content-container">
    <section class="box" id="group-chat-box">
      <ul id="chat-log" class="chat-log"></ul>

      <form id="chat-form" class="inline-form" style="margin-top: 1rem;">
        <input type="text" id="chat-input" placeholder="Nachricht schreiben..." required />
        <button type="submit">Senden</button>
      </form>
    </section>

    <section class="box">
      <details open>
        <summary>ðŸ‘¥ Gruppenmitglieder</summary>
        <ul id="member-list" class="result-list"></ul>
      </details>

      <details>
        <summary>âž• Freunde zur Gruppe einladen</summary>
        <form id="invite-form" class="inline-form">
          <input type="text" id="invite-search" placeholder="Freund suchen..." required />
          <button type="submit">ðŸ”</button>
        </form>
        <ul id="invite-results" class="result-list"></ul>
      </details>
    </section>
  </main>

  <script src="js/group-chat.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\group-list.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Gruppen</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>

  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span class="greeting">ðŸ‘¥ Deine Gruppen, <strong id="user-name">...</strong></span>
    </div>
    <div class="header-buttons">
      <button onclick="window.location.href='feed.html'">Feed</button>
      <button onclick="window.location.href='chat-list.html'">ðŸ’¬ Chats</button>
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>

  <main class="content-container">
    <section class="box">
      <h2>Neue Gruppe erstellen</h2>
      <form id="create-group-form" class="inline-form">
        <input type="text" id="group-name" placeholder="Gruppenname" required />
        <button type="submit">âž• Erstellen</button>
      </form>
    </section>

    <section class="box">
      <h2>Meine Gruppen</h2>
      <ul id="group-list" class="chat-list"></ul>
      <p id="error-msg" style="color:red;"></p>
    </section>
  </main>

  <script src="js/group-list.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Login</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header>
    <h1>fitconnect</h1>
    <nav>
      <a href="register.html">Noch kein Account? Registrieren</a>
    </nav>
  </header>

  <form id="login-form">
    <input type="text" id="username" placeholder="Benutzername" required />
    <input type="password" id="password" placeholder="Passwort" required />
    <button type="submit">Einloggen</button>
  </form>

  <p id="error-msg" style="color:red;"></p>
  <script src="js/login.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\profile.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Mein Profil</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header class="header-top">
    <div class="logo-and-user">
      <h1 class="logo">fitconnect</h1>
      <span class="greeting">ðŸ‘¤ Eingeloggt als: <strong id="user-name"></strong></span>
    </div>
    <div class="header-buttons">
      <button onclick="window.location.href='feed.html'">ZurÃ¼ck zum Feed</button>
      
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>
  </header>

  <p id="friend-status"></p>
  <button id="unfriend-btn" style="display: none;">âŒ Freundschaft beenden</button>
  <button id="add-friend-btn" style="display: none;">Freund hinzufÃ¼gen</button>
  
  <section>
    <p id="stats"></p>
    <ul id="activity-list"></ul>
  </section>

  <script src="js/profile.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\register.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fitconnect â€“ Registrierung</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header>
    <h1>fitconnect</h1>
    <nav>
      <a href="index.html">ZurÃ¼ck zum Login</a>
    </nav>
  </header>

  <form id="register-form">
    <input type="text" id="username" placeholder="Benutzername" required />
    <input type="password" id="password" placeholder="Passwort" required />
    <button type="submit">Registrieren</button>
  </form>

  <p id="success-msg" style="color:green;"></p>
  <p id="error-msg" style="color:red;"></p>

  <script src="js/register.js"></script>
</body>
</html>
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\css\style.css
--------------------------------------------------------------------------------
/* Basislayout */
body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    padding: 0;
    background-color: #f5f5f5;
    color: #333;
  }
  
  h1 {
    color: #0077cc;
    text-align: center;
  }
  
  form {
    max-width: 400px;
    margin: 2rem auto;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  
  input {
    padding: 0.8rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1rem;
  }
  
  button {
    padding: 0.8rem;
    background-color: #0077cc;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 1rem;
    cursor: pointer;
  }
  
  button:hover {
    background-color: #005fa3;
  }
  
  ul#feed-list {
    list-style: none;
    padding: 0;
    max-width: 500px;
    margin: 2rem auto;
  }
  
  ul#feed-list li {
    background-color: white;
    margin: 0.5rem 0;
    padding: 1rem;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 500px;
    margin: auto;
    padding: 1rem 0;
  }
  
  #logout-btn {
    background-color: #888;
    font-size: 0.9rem;
    padding: 0.5rem 1rem;
  }
  
  #error-msg, #success-msg {
    text-align: center;
  }

  /* Mapbox Popup Styling */
.mapboxgl-popup-content {
  font-family: Arial, sans-serif;
  font-size: 0.9rem;
  line-height: 1.4;
  max-width: 250px;
  padding: 10px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.mapboxgl-popup-content strong {
  display: block;
  margin-bottom: 4px;
}

.mapboxgl-popup-content small {
  color: #555;
  display: block;
  margin-top: 6px;
  font-size: 0.8rem;
}

.mapboxgl-popup-close-button::before {
  content: "Ã—";
  font-size: 1.2rem;
  color: #333;
 
  line-height: 1;
}





.mapboxgl-popup-close-button:focus {
  outline: none;
  box-shadow: none;
}


.header-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 900px;
  margin: auto;
  padding: 1rem 0;
  flex-wrap: wrap;
}

.logo-and-user {
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
}

.logo {
  color: #0077cc;
  font-size: 2rem;
  margin: 0;
}

.greeting {
  font-size: 1rem;
  color: #444;
}

.header-buttons {
  display: flex;
  gap: 0.5rem;
}

.logout-btn {
  background-color: #888;
}

.content-container {
  max-width: 700px;
  margin: 2rem auto;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.box {
  background-color: #ffffff;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
}

.inline-form {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.result-list {
  margin-top: 1rem;
  list-style: none;
  padding: 0;
}

.result-list li {
  margin-bottom: 0.5rem;
}

.feed-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.feed-list li {
  background-color: #fefefe;
  border: 1px solid #ddd;
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 1rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
}

.collapsible .toggle {
  width: 100%;
  text-align: left;
  background-color: #0077cc;
  color: white;
  padding: 0.8rem;
  border: none;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 6px;
  margin-bottom: 0.5rem;
}

.collapsible .toggle:hover {
  background-color: #005fa3;
}

.collapsible .content {
  padding-top: 0.5rem;
}


.chat-log {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  max-height: 400px;
  overflow-y: auto;
}

.chat-bubble {
  max-width: 70%;
  padding: 0.9rem 1.1rem;
  border-radius: 7.5px;
  box-shadow: 0 1px 1px rgba(0,0,0,0.08);
  line-height: 1.4;
  position: relative;
  word-wrap: break-word;
  display: inline-block;
}

.chat-left {
  background-color: #ffffff;
  align-self: flex-start;
  border-top-left-radius: 0;
}

.chat-right {
  background-color: #dcf8c6;
  align-self: flex-end;
  border-top-right-radius: 0;
  text-align: left;
}

.chat-bubble small {
  display: block;
  font-size: 0.75rem;
  color: #999;
  margin-top: 0.5rem;
  text-align: right;
}


.chat-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.chat-list li {
  background-color: #fff;
  padding: 1rem;
  border-radius: 8px;
  margin-bottom: 1rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  transition: background 0.2s;
}

.chat-list li:hover {
  background-color: #f0f0f0;
}

.chat-list a {
  text-decoration: none;
  color: inherit;
  display: block;
}.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\chat-list.js
--------------------------------------------------------------------------------
(async function () {
    const token = localStorage.getItem("jwt_token");
    const logoutBtn = document.getElementById("logout-btn");
    const userNameElem = document.getElementById("user-name");
    const chatList = document.getElementById("chat-list");
    const errorMsg = document.getElementById("error-msg");
  
    function parseJwt(token) {
      const payload = token.split('.')[1];
      return JSON.parse(atob(payload));
    }
  
    if (!token) {
      errorMsg.textContent = "Nicht eingeloggt.";
      return;
    }
  
    let username = "";
    try {
      const payload = parseJwt(token);
      username = payload.sub;
      if (userNameElem) userNameElem.textContent = username;
    } catch {
      errorMsg.textContent = "Fehler beim Token.";
      return;
    }
  
    if (logoutBtn) {
      logoutBtn.addEventListener("click", () => {
        localStorage.removeItem("jwt_token");
        window.location.href = "index.html";
      });
    }
  
    try {
      const res = await fetch("http://localhost:8080/messages/overview", {
        headers: { Authorization: "Bearer " + token }
      });
  
      if (!res.ok) throw new Error();
  
      const chats = await res.json();
      if (chats.length === 0) {
        chatList.innerHTML = "<li>Keine Konversationen gefunden.</li>";
        return;
      }
  
      chats.forEach(chat => {
        const li = document.createElement("li");
        li.innerHTML = `
          <a href="chat.html?with=${chat.username}">
            <strong>${chat.username}</strong><br/>
            <small>${chat.lastMessage}</small><br/>
            <span style="font-size: 0.8rem; color: #888;">
              ${new Date(chat.timestamp).toLocaleString("de-DE")}
            </span>
          </a>
        `;
        chatList.appendChild(li);
      });
  
    } catch {
      errorMsg.textContent = "Fehler beim Laden der ChatÃ¼bersicht.";
    }
  })();
  .
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\chat.js
--------------------------------------------------------------------------------
(async function () {
    const token = localStorage.getItem("jwt_token");
    const logoutBtn = document.getElementById("logout-btn");
    const chatLog = document.getElementById("chat-log");
    const chatForm = document.getElementById("chat-form");
    const chatInput = document.getElementById("chat-input");
    const chatPartnerElem = document.getElementById("chat-partner");
  
    const urlParams = new URLSearchParams(window.location.search);
    const withUser = urlParams.get("with");
  




    
    if (!token || !withUser) {
      chatLog.innerHTML = "<li>Fehler: Kein Nutzer angegeben oder nicht eingeloggt.</li>";
      return;
    }
  
    chatPartnerElem.textContent = withUser;
  
    logoutBtn.addEventListener("click", () => {
      localStorage.removeItem("jwt_token");
      window.location.href = "index.html";
    });
  
    async function loadChat() {
      const res = await fetch(`http://localhost:8080/messages/${withUser}`, {
        headers: { Authorization: "Bearer " + token }
      });
  
      if (res.status === 403) {
        chatLog.innerHTML = "<li style='color: red;'>âŒ Du bist mit diesem Nutzer nicht (mehr) befreundet.<br/>Chat nicht verfÃ¼gbar.</li>";
        chatForm.style.display = "none";
        return;
      }
      
      if (!res.ok) {
        chatLog.innerHTML = "<li>Unbekannter Fehler beim Laden des Verlaufs.</li>";
        return;
      }
  
      const messages = await res.json();
      chatLog.innerHTML = "";
      messages.forEach(m => {
        const li = document.createElement("li");
        const me = parseJwt(token).sub === m.sender.username;
        li.className = me ? "chat-bubble chat-right" : "chat-bubble chat-left";
      
        li.innerHTML = `
        <div>${m.text}</div>
        <small>${new Date(m.timestamp).toLocaleString('de-DE')}</small>
      `;
      
      chatLog.appendChild(li);
      });
  
      chatLog.scrollTop = chatLog.scrollHeight;
    }
  
    chatForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const text = chatInput.value.trim();
      if (!text) return;
  
      await fetch("http://localhost:8080/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + token
        },
        body: JSON.stringify({ recipient: withUser, text })
      });
  
      chatInput.value = "";
      await loadChat();
    });
  
    function parseJwt(token) {
      const payload = token.split('.')[1];
      return JSON.parse(atob(payload));
    }
  
    await loadChat();



    const eventSource = new EventSource("http://localhost:8080/activities/feed-stream");

    eventSource.addEventListener("new-message", (event) => {
      const [recipient, sender] = event.data.split("|");
    
      const currentUser = parseJwt(token).sub;
      const chatPartner = new URLSearchParams(window.location.search).get("with");
    
      const isRelevant = (recipient === currentUser && sender === chatPartner);
      if (isRelevant) {
        loadChat(); // Neues anzeigen
      }
    });


    

  eventSource.addEventListener("friend-removed", (event) => {
    const [target, by] = event.data.split("|");
    const currentUser = parseJwt(token).sub;
  
    if (target === currentUser) {
      const notice = document.createElement("div");
      notice.textContent = `ðŸš« ${by} hat die Freundschaft beendet.`;
      notice.style.background = "#ffdddd";
      notice.style.color = "#800";
      notice.style.padding = "1rem";
      notice.style.textAlign = "center";
      notice.style.fontWeight = "bold";
      notice.style.marginBottom = "1rem";
  
      document.body.prepend(notice);
    }
  });

  function parseJwt(token) {
    const payload = token.split('.')[1];
    return JSON.parse(atob(payload));
  }

  })();
  .
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\feed.js
--------------------------------------------------------------------------------
(async function () {
  const token = localStorage.getItem("jwt_token");

  function parseJwt(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  }

  const errorMsg = document.getElementById("error-msg");
  const feedList = document.getElementById("feed-list");
  const logoutBtn = document.getElementById("logout-btn");
  const activityForm = document.getElementById("activity-form");
  const activityInput = document.getElementById("activity-input");
  const activityLocation = document.getElementById("activity-location");
  const userGreeting = document.getElementById("user-greeting");

  // PrÃ¼fen, ob ein Token vorhanden ist
  if (!token) {
    errorMsg.textContent = "Nicht eingeloggt. Bitte zuerst anmelden.";
    return;
  }

  // Username aus dem JWT-Token herauslesen
  let username = "";
try {
  const payload = JSON.parse(atob(token.split('.')[1]));
  username = payload.sub;
  document.getElementById("user-name").textContent = username;
} catch (err) {
  userGreeting.textContent = "";
}

// Freunde-Button separat danach initialisieren
const friendsBtn = document.getElementById("friends-btn");
if (friendsBtn && username) {
  fetch("http://localhost:8080/friends/requests", {
    headers: { Authorization: "Bearer " + token }
  })
    .then(res => res.json())
    .then(requests => {
      if (requests.length > 0) {
        friendsBtn.textContent = `ðŸ‘¥ Freunde (${requests.length})`;
      }
    });

  friendsBtn.addEventListener("click", () => {
    window.location.href = "freunde.html";
  });
}

  

  // Map initialisieren
  mapboxgl.accessToken = "pk.eyJ1IjoibmFnYXJkIiwiYSI6ImNtYXhvcmx5MjAwanMyd3F1MGF0c2FpbHAifQ.y41D8qaCugwI3rVrNV0AJQ";
  const map = new mapboxgl.Map({
    container: "map",
    style: "mapbox://styles/mapbox/streets-v12",
    center: [8.63899, 49.64309], // z. B. Darmstadt
    zoom: 11
  });

  let currentMarker = null;
  const activityMarkers = new Map();
  const deletedIds = new Set();

  // Klick-Event auf der Karte => Marker setzen + Location ins Input
  map.on('click', function (e) {
    const { lng, lat } = e.lngLat;
    if (currentMarker) currentMarker.remove();
    currentMarker = new mapboxgl.Marker()
      .setLngLat([lng, lat])
      .setPopup(new mapboxgl.Popup({ offset: 25 }).setText("Ort ausgewÃ¤hlt"))
      .addTo(map);
    activityLocation.value = `${lng.toFixed(5)},${lat.toFixed(5)}`;
  });

  // Marker auf die Karte bringen, falls Location vorhanden
  function addMarkerIfLocationExists(activity) {
    // Falls bereits "gelÃ¶scht" markiert, ignorieren
    if (deletedIds.has(activity.id)) {
      console.log("âšª Marker unterdrÃ¼ckt fÃ¼r gelÃ¶schte ID:", activity.id);
      return;
    }

    if (activity.location) {
      const [lng, lat] = activity.location.split(',').map(Number);

      // Einen evtl. vorhandenen Marker fÃ¼r dieselbe ID entfernen
      if (activityMarkers.has(activity.id)) {
        activityMarkers.get(activity.id).remove();
      }

      // Popup-Info definieren
      const popup = new mapboxgl.Popup({ offset: 25, maxWidth: '200px' })
        .setHTML(`
          <strong>${activity.user}</strong><br/>
          ${activity.text}<br/>
          <small>${new Date(activity.timestamp).toLocaleString('de-DE')}</small>
        `);

      // Neuen Marker erstellen
      const marker = new mapboxgl.Marker()
        .setLngLat([lng, lat])
        .setPopup(popup)
        .addTo(map);

      // Hover-Effekt, damit das Popup beim DrÃ¼berfahren erscheint
      marker.getElement().dataset.markerId = activity.id;
      marker.getElement().addEventListener('mouseenter', () => popup.addTo(map));
      marker.getElement().addEventListener('mouseleave', () => popup.remove());

      // In der Map speichern
      activityMarkers.set(activity.id, marker);
      console.log("ðŸ“ Marker gesetzt fÃ¼r ID:", activity.id);
    }
  }

  // Feed vom Server holen und listen
  async function loadFeed() {
    try {
      const response = await fetch("http://localhost:8080/activities", {
        headers: { Authorization: "Bearer " + token }
      });
      if (!response.ok) throw new Error("Fehler beim Laden");

      const activities = await response.json();
      feedList.innerHTML = "";
      // Vorherige Marker entfernen
      activityMarkers.forEach(marker => marker.remove());
      activityMarkers.clear();
      deletedIds.clear();

      // Jeden Eintrag anfÃ¼gen
      activities.forEach(activity => {
        appendToFeed(activity);
        addMarkerIfLocationExists(activity);
      });
    } catch (err) {
      errorMsg.textContent = "Fehler beim Laden des Feeds.";
    }
  }

  // Eine einzelne AktivitÃ¤t in die Feed-Liste einfÃ¼gen
  function appendToFeed(activity) {
    const li = document.createElement("li");
    li.dataset.id = activity.id;

    // Icon je nach Sichtbarkeit
    const visibilityIcon = {
      PUBLIC: "ðŸ”“ Ã–ffentlich",
      FRIENDS_ONLY: "ðŸ«‚ Nur Freunde",
      PRIVATE: "ðŸ”’ Privat"
    }[activity.visibility || "PUBLIC"];

    li.innerHTML = `
      <span>
        <a href="profile.html?user=${activity.user}">${activity.user}</a> â€“ <span data-id="${activity.id}">${activity.text}</span><br/>
        <small style="color: #666;">${visibilityIcon}</small>
      </span>
      ${
        activity.user?.toLowerCase?.() === username?.toLowerCase?.()
          ? `
            <button onclick="editActivity(${activity.id})">âœŽ</button>
            <button onclick="deleteActivity(${activity.id})">ðŸ—‘ï¸</button>
          `
          : ""
      }
    `;

    // Etwaige Duplikate vorher entfernen
    const existing = document.querySelector(`li[data-id="${activity.id}"]`);
    if (existing) existing.remove();

    // Ganz oben einfÃ¼gen
    feedList.insertBefore(li, feedList.firstChild);
  }

  // Formular zum Posten einer neuen AktivitÃ¤t
  activityForm.addEventListener("submit", async function (e) {
    e.preventDefault();
    const text = activityInput.value.trim();
    const location = activityLocation.value.trim();
    if (!text) return;

    const visibility = document.getElementById("activity-visibility").value;

    const response = await fetch("http://localhost:8080/activities", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + token
      },
      body: JSON.stringify({ text, location, visibility })
    });

    if (!response.ok) return;
    const createdActivity = await response.json();
    appendToFeed(createdActivity);
    addMarkerIfLocationExists(createdActivity);
    activityInput.value = "";
    activityLocation.value = "";
  });

  // Logout-Button
  logoutBtn.addEventListener("click", () => {
    localStorage.removeItem("jwt_token");
    window.location.href = "index.html";
  });

  // Bearbeiten einer AktivitÃ¤t
  window.editActivity = async function (id) {
    const newText = prompt("Neue AktivitÃ¤t:");
    if (!newText) return;

    let location = null;
    // Wenn fÃ¼r diese ID ein Marker existiert, nimm dessen Koordinaten
    if (activityMarkers.has(id)) {
      const lngLat = activityMarkers.get(id).getLngLat();
      location = `${lngLat.lng.toFixed(5)},${lngLat.lat.toFixed(5)}`;
    }

    await fetch("http://localhost:8080/activities/" + id, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + token
      },
      body: JSON.stringify({ text: newText, location })
    });

    // Keine direkte Aktualisierung hier, da es per SSE geschieht (activity-update)
  };

  // LÃ¶schen einer AktivitÃ¤t
  window.deleteActivity = async function (id) {
    if (!confirm("Wirklich lÃ¶schen?")) return;
  
    const response = await fetch("http://localhost:8080/activities/" + id, {
      method: "DELETE",
      headers: { Authorization: "Bearer " + token }
    });
  
    if (response.ok) {
      // **Sofort** den Eintrag im Feed entfernen
      const li = document.querySelector(`li[data-id="${id}"]`);
      if (li) li.remove();
  
      // ... und gleich den Marker entfernen
      if (activityMarkers.has(id)) {
        const marker = activityMarkers.get(id);
        marker.remove();
        marker.setPopup(null);
        const el = marker.getElement();
        if (el && el.parentNode) {
          el.parentNode.removeChild(el);
        }
        activityMarkers.delete(id);
      }
      if (currentMarker) {
        currentMarker.remove();
        currentMarker = null;
      }
      console.log("ðŸ—‘ï¸ DELETE erfolgreich â€“ warte zusÃ¤tzlich auf SSE fÃ¼r die anderen.");
    }
  };

  // Feed beim Start laden
  loadFeed();

  // SSE-Verbindung aufbauen
  const eventSource = new EventSource("http://localhost:8080/activities/feed-stream");

  // Neue AktivitÃ¤t kommt rein
  eventSource.addEventListener("activity", (event) => {
    const activity = JSON.parse(event.data);
    appendToFeed(activity);
    addMarkerIfLocationExists(activity);
  });

  // AktivitÃ¤t wurde bearbeitet
  eventSource.addEventListener("activity-update", (event) => {
    const updated = JSON.parse(event.data);

    // Text im Feed austauschen
    const span = document.querySelector(`span[data-id="${updated.id}"]`);
    if (span) span.textContent = updated.text;

    // Falls ein Marker vorhanden ist, entfernen und neu setzen
    if (activityMarkers.has(updated.id)) {
      activityMarkers.get(updated.id).remove();
      activityMarkers.delete(updated.id);
    }
    addMarkerIfLocationExists(updated);
  });

  // AktivitÃ¤t wurde gelÃ¶scht
  eventSource.addEventListener("activity-delete", (event) => {
    const id = parseInt(event.data);
    console.log("SSE Delete-Event empfangen:", event.data);
    // 1) Das <li> aus der Feed-Liste entfernen
    const li = document.querySelector(`li[data-id="${id}"]`);
    if (li) li.remove();

    // 2) Marker entfernen
    if (activityMarkers.has(id)) {
        const marker = activityMarkers.get(id);

        try {
            marker.remove();
        } catch (err) {
            console.warn("âš ï¸ marker.remove() fehlgeschlagen:", err);
        }

        // Optional: Popup â€žentkoppelnâ€œ
        marker.setPopup(null);

        // 3) Map-Eintrag entfernen
        activityMarkers.delete(id);

        // Eventuelles DOM-Element vom Marker-Icon nochmal entfernen
        const el = marker.getElement();
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    }
});

eventSource.addEventListener("friend-request", (event) => {
  const targetUsername = event.data;

  if (targetUsername === username) {
    const notice = document.createElement("div");
    notice.textContent = "ðŸ”” Neue Freundschaftsanfrage erhalten!";
    notice.style.background = "#0077cc";
    notice.style.color = "white";
    notice.style.padding = "1rem";
    notice.style.textAlign = "center";
    notice.style.fontWeight = "bold";
    notice.style.marginBottom = "1rem";

    document.body.prepend(notice);

    setTimeout(() => notice.remove(), 10000);
  }
});


eventSource.addEventListener("friend-removed", (event) => {
  const [target, by] = event.data.split("|");
  const currentUser = parseJwt(token).sub;

  if (target === currentUser) {
    const notice = document.createElement("div");
    notice.textContent = `ðŸš« ${by} hat die Freundschaft beendet.`;
    notice.style.background = "#ffdddd";
    notice.style.color = "#800";
    notice.style.padding = "1rem";
    notice.style.textAlign = "center";
    notice.style.fontWeight = "bold";
    notice.style.marginBottom = "1rem";

    document.body.prepend(notice);
  }
});

 // ðŸ” Nutzer-Suche
 const searchForm = document.getElementById("user-search-form");
 const searchResults = document.getElementById("search-results");

 if (searchForm && searchResults) {
   searchForm.addEventListener("submit", async (e) => {
     e.preventDefault();
     const query = document.getElementById("search-query").value.trim();
     if (!query) return;

     try {
       const res = await fetch("http://localhost:8080/users/search?query=" + encodeURIComponent(query), {
         headers: { Authorization: "Bearer " + token }
       });

       if (!res.ok) throw new Error();

       const users = await res.json();
       searchResults.innerHTML = "";
       if (users.length === 0) {
         searchResults.innerHTML = "<li>Kein Benutzer gefunden.</li>";
       } else {
         users.forEach(user => {
           const li = document.createElement("li");
           li.innerHTML = `<a href="profile.html?user=${user.username}">${user.username}</a>`;
           searchResults.appendChild(li);
         });
       }
     } catch {
       searchResults.innerHTML = "<li>Fehler bei der Suche.</li>";
     }
   });
 }

 window.toggleBox = function(button) {
  const content = button.nextElementSibling;
  const isOpen = content.style.display === "block";
  content.style.display = isOpen ? "none" : "block";

  if (isOpen) {
    button.textContent = button.textContent.replace("verbergen", "anzeigen");
  } else {
    button.textContent = button.textContent.replace("anzeigen", "verbergen");
  }

  // Map neu zeichnen, falls betroffen
  if (content.querySelector("#map")) {
    map.resize();
  }
};

})();


.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\friends.js
--------------------------------------------------------------------------------
(async function () {
  const token = localStorage.getItem("jwt_token");
  const userNameElem = document.getElementById("user-name");
  const friendsList = document.getElementById("friends-list");
  const requestsList = document.getElementById("requests-list");


  const eventSource = new EventSource("http://localhost:8080/activities/feed-stream");

  eventSource.addEventListener("friend-removed", (event) => {
    const [target, by] = event.data.split("|");
    const currentUser = parseJwt(token).sub;
  
    if (target === currentUser) {
      const notice = document.createElement("div");
      notice.textContent = `ðŸš« ${by} hat die Freundschaft beendet.`;
      notice.style.background = "#ffdddd";
      notice.style.color = "#800";
      notice.style.padding = "1rem";
      notice.style.textAlign = "center";
      notice.style.fontWeight = "bold";
      notice.style.marginBottom = "1rem";
  
      document.body.prepend(notice);
    }
  });

  function parseJwt(token) {
    const payload = token.split('.')[1];
    return JSON.parse(atob(payload));
  }




  if (!token) {
    if (userNameElem) userNameElem.textContent = "Nicht eingeloggt.";
    return;
  }

  let username = "";
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    username = payload.sub;
    if (userNameElem) userNameElem.textContent = username;
  } catch (err) {
    if (userNameElem) userNameElem.textContent = "";
  }

  // Freunde-Button aktualisieren
  const friendsBtn = document.getElementById("friends-btn");
  if (friendsBtn && username) {
    fetch("http://localhost:8080/friends/requests", {
      headers: { Authorization: "Bearer " + token }
    })
      .then(res => res.json())
      .then(requests => {
        if (requests.length > 0) {
          friendsBtn.textContent = `ðŸ‘¥ Freunde (${requests.length})`;
        }
      });

    friendsBtn.addEventListener("click", () => {
      window.location.href = "freunde.html";
    });
  }

  // Logout
  const logoutBtn = document.getElementById("logout-btn");
  if (logoutBtn) {
    logoutBtn.addEventListener("click", () => {
      localStorage.removeItem("jwt_token");
      window.location.href = "index.html";
    });
  }

  async function loadFriends() {
    const res = await fetch("http://localhost:8080/friends", {
      headers: { Authorization: "Bearer " + token }
    });
    const users = await res.json();
    friendsList.innerHTML = "";
    users.forEach(user => {
      const li = document.createElement("li");
      li.innerHTML = `
        <a href="profile.html?user=${user.username}">${user.username}</a>
        <button onclick="startChat('${user.username}')">ðŸ’¬</button>
        <button onclick="unfriend('${user.username}')">âŒ</button>
      `;
      friendsList.appendChild(li);
    });
  }

  async function loadRequests() {
    const res = await fetch("http://localhost:8080/friends/requests", {
      headers: { Authorization: "Bearer " + token }
    });
    const requests = await res.json();
    requestsList.innerHTML = "";
    requests.forEach(req => {
      const li = document.createElement("li");
      li.innerHTML = `
        <a href="profile.html?user=${req.requester.username}">${req.requester.username}</a>
        <button onclick="respond(${req.id}, true)">âœ”ï¸</button>
        <button onclick="respond(${req.id}, false)">âŒ</button>
      `;
      requestsList.appendChild(li);
    });
  }

  window.respond = async function (id, accept) {
    await fetch("http://localhost:8080/friends/respond/" + id + "?accept=" + accept, {
      method: "POST",
      headers: { Authorization: "Bearer " + token }
    });
    await loadFriends();
    await loadRequests();
  };

  window.unfriend = async function (username) {
    if (!confirm(`Freundschaft mit ${username} wirklich beenden?`)) return;

    await fetch(`http://localhost:8080/friends/remove/${username}`, {
      method: "DELETE",
      headers: { Authorization: "Bearer " + token }
    });

    await loadFriends();
    await loadRequests();
  };

  window.startChat = function (username) {
    window.location.href = `chat.html?with=${username}`;
  };

  await loadFriends();
  await loadRequests();
})();
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\group-chat.js
--------------------------------------------------------------------------------
(async function () {
    const token = localStorage.getItem("jwt_token");
    const chatLog = document.getElementById("chat-log");
    const chatForm = document.getElementById("chat-form");
    const chatInput = document.getElementById("chat-input");
    const groupTitle = document.getElementById("group-title");
    const memberList = document.getElementById("member-list");
    const inviteForm = document.getElementById("invite-form");
    const inviteSearch = document.getElementById("invite-search");
    const inviteResults = document.getElementById("invite-results");
  
    const urlParams = new URLSearchParams(window.location.search);
    const groupId = urlParams.get("gid");
  
    if (!token || !groupId) {
      chatLog.innerHTML = "<li>âŒ Kein Token oder Gruppen-ID vorhanden.</li>";
      chatForm.style.display = "none";
      return;
    }
  
    const currentUser = parseJwt(token).sub;
    try {
        const res = await fetch("http://localhost:8080/groups/" + groupId, {
          headers: { Authorization: "Bearer " + token }
        });
        if (res.ok) {
          const group = await res.json();
          groupTitle.textContent = group.name;
        } else {
          groupTitle.textContent = `Gruppe #${groupId}`;
        }
      } catch {
        groupTitle.textContent = `Gruppe #${groupId}`;
      }
  
    async function loadChat() {
      const res = await fetch(`http://localhost:8080/group-messages/${groupId}`, {
        headers: { Authorization: "Bearer " + token }
      });
  
      if (res.status === 403) {
        chatLog.innerHTML = "<li style='color:red;'>âŒ Du bist kein Mitglied dieser Gruppe.</li>";
        chatForm.style.display = "none";
        return;
      }
  
      const messages = await res.json();
      chatLog.innerHTML = "";
      messages.forEach(m => {
        const li = document.createElement("li");
        const me = m.sender.username === currentUser;
        li.className = me ? "chat-bubble chat-right" : "chat-bubble chat-left";
        li.innerHTML = `
          <div>${m.text}</div>
          <small>${m.sender.username} â€¢ ${new Date(m.timestamp).toLocaleString("de-DE")}</small>
        `;
        chatLog.appendChild(li);
      });
  
      chatLog.scrollTop = chatLog.scrollHeight;
    }
  
    async function loadMembers() {
      const res = await fetch(`http://localhost:8080/groups/${groupId}/members`, {
        headers: { Authorization: "Bearer " + token }
      });
  
      if (!res.ok) return;
  
      const users = await res.json();
      memberList.innerHTML = "";
      users.forEach(u => {
        const li = document.createElement("li");
        li.textContent = u.username;
        memberList.appendChild(li);
      });
    }
  
    chatForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const text = chatInput.value.trim();
      if (!text) return;
  
      await fetch(`http://localhost:8080/group-messages/${groupId}?text=${encodeURIComponent(text)}`, {
        method: "POST",
        headers: { Authorization: "Bearer " + token }
      });
  
      chatInput.value = "";
      await loadChat();
    });
  
    inviteForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const query = inviteSearch.value.trim();
      if (!query) return;
  
      const res = await fetch("http://localhost:8080/users/search?query=" + encodeURIComponent(query), {
        headers: { Authorization: "Bearer " + token }
      });
  
      if (!res.ok) return;
  
      const users = await res.json();
      inviteResults.innerHTML = "";
  
      users.forEach(u => {
        const li = document.createElement("li");
        li.innerHTML = `
          ${u.username}
          <button data-user="${u.username}">âž• Einladen</button>
        `;
        inviteResults.appendChild(li);
      });
  
      // Invite-KnÃ¶pfe
      inviteResults.querySelectorAll("button").forEach(btn => {
        btn.addEventListener("click", async () => {
          const friendUsername = btn.dataset.user;
  
          const inviteRes = await fetch(
            `http://localhost:8080/groups/${groupId}/invite?friendUsername=${friendUsername}`,
            {
              method: "POST",
              headers: { Authorization: "Bearer " + token }
            }
          );
  
          if (inviteRes.ok) {
            btn.disabled = true;
            btn.textContent = "âœ… Eingeladen";
            await loadMembers();
          }
        });
      });
    });
  
    const eventSource = new EventSource("http://localhost:8080/activities/feed-stream");
  
    eventSource.addEventListener("group-message-" + groupId, () => {
      loadChat();
    });
  
    function parseJwt(token) {
      const payload = token.split('.')[1];
      return JSON.parse(atob(payload));
    }
  
    await loadChat();
    await loadMembers();
  })();
  .
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\group-list.js
--------------------------------------------------------------------------------
(async function () {
    const token = localStorage.getItem("jwt_token");
    const logoutBtn = document.getElementById("logout-btn");
    const userNameElem = document.getElementById("user-name");
    const groupList = document.getElementById("group-list");
    const groupForm = document.getElementById("create-group-form");
    const groupNameInput = document.getElementById("group-name");
    const errorMsg = document.getElementById("error-msg");
  
    function parseJwt(token) {
      const payload = token.split('.')[1];
      return JSON.parse(atob(payload));
    }
  
    if (!token) {
      errorMsg.textContent = "Nicht eingeloggt.";
      return;
    }
  
    let username = "";
    try {
      const payload = parseJwt(token);
      username = payload.sub;
      if (userNameElem) userNameElem.textContent = username;
    } catch {
      errorMsg.textContent = "Token ungÃ¼ltig.";
      return;
    }
  
    if (logoutBtn) {
      logoutBtn.addEventListener("click", () => {
        localStorage.removeItem("jwt_token");
        window.location.href = "index.html";
      });
    }
  
    async function loadGroups() {
      try {
        const res = await fetch("http://localhost:8080/groups", {
          headers: { Authorization: "Bearer " + token }
        });
  
        if (!res.ok) throw new Error();
        const groups = await res.json();
        groupList.innerHTML = "";
  
        if (groups.length === 0) {
          groupList.innerHTML = "<li>Keine Gruppen gefunden.</li>";
          return;
        }
  
        groups.forEach(g => {
          const li = document.createElement("li");
          li.innerHTML = `
            <a href="group-chat.html?gid=${g.id}">
              <strong>${g.name}</strong><br/>
              <small>Erstellt von ${g.createdBy}</small>
            </a>
          `;
          groupList.appendChild(li);
        });
  
      } catch {
        errorMsg.textContent = "Fehler beim Laden der Gruppen.";
      }
    }
  
    groupForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const name = groupNameInput.value.trim();
      if (!name) return;
  
      try {
        await fetch("http://localhost:8080/groups?name=" + encodeURIComponent(name), {
          method: "POST",
          headers: { Authorization: "Bearer " + token }
        });
        groupNameInput.value = "";
        await loadGroups();
      } catch {
        errorMsg.textContent = "Fehler beim Erstellen.";
      }
    });
  
    await loadGroups();
  })();.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\login.js
--------------------------------------------------------------------------------
document.getElementById("login-form").addEventListener("submit", async function (e) {
  e.preventDefault();

  const username = document.getElementById("username").value.trim();
  const password = document.getElementById("password").value.trim();
  const errorMsg = document.getElementById("error-msg");

  try {
    const response = await fetch("http://localhost:8080/auth/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error("Login fehlgeschlagen");
    }

    const data = await response.json();
    localStorage.setItem("jwt_token", data.token);
    window.location.href = "feed.html";
  } catch (err) {
    errorMsg.textContent = "Login fehlgeschlagen. Bitte Ã¼berprÃ¼fe deine Eingaben.";
  }
});
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\profile.js
--------------------------------------------------------------------------------
(async function () {
  const token = localStorage.getItem("jwt_token");
  const userNameElem = document.getElementById("user-name");
  const list = document.getElementById("activity-list");
  const stats = document.getElementById("stats");
  const addFriendBtn = document.getElementById("add-friend-btn");
  const unfriendBtn = document.getElementById("unfriend-btn");
  const friendStatus = document.getElementById("friend-status");

  const urlParams = new URLSearchParams(window.location.search);
  const targetUser = urlParams.get("user");


  const eventSource = new EventSource("http://localhost:8080/activities/feed-stream");

  eventSource.addEventListener("friend-removed", (event) => {
    const [target, by] = event.data.split("|");
    const currentUser = parseJwt(token).sub;
  
    if (target === currentUser) {
      const notice = document.createElement("div");
      notice.textContent = `ðŸš« ${by} hat die Freundschaft beendet.`;
      notice.style.background = "#ffdddd";
      notice.style.color = "#800";
      notice.style.padding = "1rem";
      notice.style.textAlign = "center";
      notice.style.fontWeight = "bold";
      notice.style.marginBottom = "1rem";
  
      document.body.prepend(notice);
    }
  });

  function parseJwt(token) {
    const payload = token.split('.')[1];
    return JSON.parse(atob(payload));
  }



  
  if (!token) {
    userNameElem.textContent = "Nicht eingeloggt";
    return;
  }

  let currentUser = "";
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    currentUser = payload.sub;
    if (userNameElem) userNameElem.textContent = currentUser;
  } catch (err) {
    if (userNameElem) userNameElem.textContent = "";
  }

  // Freunde-Button aktualisieren
  const friendsBtn = document.getElementById("friends-btn");
  if (friendsBtn && currentUser) {
    fetch("http://localhost:8080/friends/requests", {
      headers: { Authorization: "Bearer " + token }
    })
      .then(res => res.json())
      .then(requests => {
        if (requests.length > 0) {
          friendsBtn.textContent = `ðŸ‘¥ Freunde (${requests.length})`;
        }
      });

    friendsBtn.addEventListener("click", () => {
      window.location.href = "freunde.html";
    });
  }

  // Logout
  const logoutBtn = document.getElementById("logout-btn");
  if (logoutBtn) {
    logoutBtn.addEventListener("click", () => {
      localStorage.removeItem("jwt_token");
      window.location.href = "index.html";
    });
  }

  const viewedUser = targetUser || currentUser;

  // AktivitÃ¤ten laden
  try {
    const response = await fetch(viewedUser === currentUser
      ? "http://localhost:8080/activities/me/activities"
      : "http://localhost:8080/activities?user=" + viewedUser,
      {
        headers: { "Authorization": "Bearer " + token }
      });

    if (!response.ok) throw new Error("Fehler beim Laden");

    const data = await response.json();
    stats.textContent = `${viewedUser === currentUser
      ? "Du hast"
      : "Dieser Nutzer hat"} insgesamt ${data.length} AktivitÃ¤ten erfasst.`;

    list.innerHTML = "";
    data.forEach(a => {
      const li = document.createElement("li");
      li.textContent = `${a.text} (${new Date(a.timestamp).toLocaleString()})`;
      list.appendChild(li);
    });

  } catch (err) {
    stats.textContent = "Fehler beim Laden der AktivitÃ¤ten.";
  }

  // Freundschaftsstatus nur anzeigen, wenn fremdes Profil
  if (viewedUser !== currentUser) {
    const res = await fetch(`http://localhost:8080/friends/${viewedUser}/status`, {
      headers: { Authorization: "Bearer " + token }
    });
    const status = await res.text();
    friendStatus.textContent = "Beziehungsstatus: " + status;

    if (status === "NONE") {
      addFriendBtn.style.display = "inline-block";
      addFriendBtn.addEventListener("click", async () => {
        const req = await fetch(`http://localhost:8080/friends/request/${viewedUser}`, {
          method: "POST",
          headers: { Authorization: "Bearer " + token }
        });
        if (req.ok) {
          friendStatus.textContent = "Anfrage gesendet!";
          addFriendBtn.style.display = "none";
        }
      });
    } else if (status === "ACCEPTED") {
      unfriendBtn.style.display = "inline-block";
      unfriendBtn.addEventListener("click", async () => {
        if (!confirm(`Freundschaft mit ${viewedUser} wirklich beenden?`)) return;

        const res = await fetch(`http://localhost:8080/friends/remove/${viewedUser}`, {
          method: "DELETE",
          headers: { Authorization: "Bearer " + token }
        });

        if (res.ok) {
          friendStatus.textContent = "Freundschaft beendet.";
          unfriendBtn.style.display = "none";
          addFriendBtn.style.display = "inline-block";
        }
      });
    }
  }
})();
.
.
--------------------------------------------------------------------------------
Datei: C:\Bootcamp\fitconnect\fitconnect\frontend\js\register.js
--------------------------------------------------------------------------------
document.getElementById("register-form").addEventListener("submit", async function (e) {
  e.preventDefault();

  const username = document.getElementById("username").value.trim();
  const password = document.getElementById("password").value.trim();
  const errorMsg = document.getElementById("error-msg");
  const successMsg = document.getElementById("success-msg");

  try {
    const response = await fetch("http://localhost:8080/auth/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error("Registrierung fehlgeschlagen");
    }

    successMsg.textContent = "Registrierung erfolgreich! Du wirst weitergeleitet...";
    errorMsg.textContent = "";

    setTimeout(() => {
      window.location.href = "index.html";
    }, 1500);
  } catch (err) {
    errorMsg.textContent = "Benutzername evtl. bereits vergeben.";
    successMsg.textContent = "";
  }
});
.
Drcken Sie eine beliebige Taste . . . 
